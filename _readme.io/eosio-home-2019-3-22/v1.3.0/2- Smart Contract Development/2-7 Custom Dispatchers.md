---
title: "2.7 Custom Dispatchers"
excerpt: ""
---
[block:api-header]
{
  "title": "Introduction: the EOSIO_ABI Macro"
}
[/block]
Up until now, we've been using a nifty macro called `EOSIO_ABI` to handle dispatching actions sent to the WASM API to our functions inside our contracts.

[block:code]
{
  "codes": [
    {
      "code": "EOSIO_ABI( addressbook, (upsert)(notify)(erase) )",
      "language": "text"
    }
  ]
}
[/block]
The `EOSIO_ABI` macro abstracts the dispatcher with a common pattern.
- The base class is set, `myclass`
- The actions exposed are defined.
- A dispatched action's arguments are positional.


[block:api-header]
{
  "title": "Step 1: Understanding the EOSIO_ABI macro"
}
[/block]
Every smart contract must provide an `apply` action handler, or "dispatcher". The dispatcher is a function that listens to all incoming actions and performs the desired behavior. In order to respond to a particular action, code is required to identify and respond to specific actions requests. `apply` uses the `receiver`, `code`, and `action` input parameters as filters to map to the desired functions that implement particular actions. The `apply` function can filter on the `code` parameter using something like the following

```cpp
if (code == N(${contract_name}) {
   // your handler to respond to particular code
}
```

Within a given `code`, one can respond to a particular action by filtering on the `action` parameter. This is normally used in conjunction with the code filter.

```cpp
if (action == N(${action_name}) {
    //your handler to respond to a particular action
}
```

To simplify the work for contract developers, the `EOSIO_ABI` macro encapsulates the lower level action mapping details of the `apply` function, enabling developers to focus on their application implementation.
```cpp
#define EOSIO_ABI( TYPE, MEMBERS ) \
extern "C" { \
   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \
      auto self = receiver; \
      if( code == self ) { \
         TYPE thiscontract( self ); \
         switch( action ) { \
            EOSIO_API( TYPE, MEMBERS ) \
         } \
         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \
      } \
   } \
} \
```
A developer needs only to specify the `code` and `action` names from the contract in the macro, and all of the underlying C code mapping logic is generated by the macro. An example of use of the macro can be seen above, i.e., `EOSIO_ABI( hello, (hi) )` where `hello` and `hi` are values from the contract.

In this example you can see there is one function, `apply`. All it does is log the actions delivered and makes no other checks. Anyone can deliver any action at any time provided the block producers allow it. Absent any required signatures, the contract will be billed for the bandwidth consumed.

## apply

`apply` is the action handler, it listens to all incoming actions and reacts according to the specifications within the function. The `apply` function requires two input parameters, `code` and `action`.

## code filter

In order to respond to a particular action, structure the `apply` function as follows. You may also construct a response to general actions by omitting the code filter.

```base
if (code == N(${contract_name}) {
    // your handler to respond to particular code
}
```

You can also define responses to respective actions in the code block.

## action filter

To respond to a particular action, structure your `apply` function as follows. This is normally used in conjuction with the code filter.

```base
if (action == N(${action_name}) {
    //your handler to respond to a particular action
}
```
[block:api-header]
{
  "title": "Step 2: Converting EOSIO_ABI to various styles of dispatcher"
}
[/block]
The `addressbook` contract from previous tutorials, we used the `EOSIO_ABI` macro as our dispatcher. We'll now take the functionality of this macro and apply it to various possible dispatcher patterns.
[block:code]
{
  "codes": [
    {
      "code": "EOSIO_ABI( addressbook, (upsert)(notify)(erase) )",
      "language": "cplusplus"
    }
  ]
}
[/block]
## Exploded EOSIO_ABI Dispatcher
This example dispatcher closely mimics how the EOSIO_ABI macro works when you've striped away the macros. Since this dispatcher uses `execute_action()`, our actions will receive positional arguments so eosio-cpp's ABI generator can be used. This is not a good solution if you are handling actions from another contract. 
[block:code]
{
  "codes": [
    {
      "code": "extern \"C\" {\n  void apply(uint64_t receiver, uint64_t code, uint64_t action) {\n    auto self = receiver;\n    if(code==self){\n      addressbook _addressbook(self);\n      switch(action){\n      \tcase \"upsert\": return execute_action( &_addressbook, &addressbook::upsert );\n        case \"notify\": return execute_action( &_addressbook, &addressbook::notify );\n        case \"erase\":  return execute_action( &_addressbook, &addressbook::erase );\n      }\n  }\n};",
      "language": "cplusplus"
    }
  ]
}
[/block]
1. Check that `code==self` before dispatching an action.
2. Instantiate `addressbook` 
3. Throw the `action` into a `switch()` 
4. Pass a reference to our `addressbook` instance, and a caller reference to the public action of the `addressbook` class to the `execute_action` function

The above pattern is simply an exploded view of the EOSIO_ABI and EOSIO_API macros without actually using them, hence the "Exploded EOSIO_ABI Dispatcher."

The exploded dispatcher pattern above is really only suitable when handling internal actions. If your contract needs to handle actions sent by another contract in a specific way, using a `switch()` introduces logical ambiguity which may introduce vulnerabilities. If you like the tradeoffs of this pattern, but wish to handle income actions from another contract, see the next example.

## Flexible/Compatible Dispatcher 
This pattern provides more control over security at the expense of maintainability. Utilizing `if...else if` statements as opposed to a `switch` inherently provides more granularity. 

This dispatcher adds a `transfer` action from `eosio.token` in the last case. 

This pattern is a good mix between convention and configuration. While the dispatcher itself requires some meaty configuration, we utilize the benefits of `execute_action` to automatically set `_self` and to unpack the arguments of the given action and call the action (class method) with these unpacked parameters. Because of this, our actions (class methods) will receive positional arguments and thus, [eosio-cpp](https://github.com/EOSIO/eosio.cdt#eosio-cpp)'s ABI generator can be used. It's flexible in the dispatcher and compatible with ABIs. 
[block:callout]
{
  "type": "info",
  "body": "The `addressbook` contract previously authored does not include a `transfer` action, it's included for demonstrative purposes only."
}
[/block]

[block:code]
{
  "codes": [
    {
      "code": "extern \"C\" {\n  void apply(uint64_t self, uint64_t code, uint64_t action) {\n    addressbook _addressbook(self);\n    if(code==self && action==N(upsert)) {\n      execute_action( &_addressbook, &addressbook::upsert );\n    }\n    else if(code==self && action==N(notify)) {\n      execute_action( &_addressbook, &addressbook::notify );\n    }\n    else if(code==self && action==N(erase)) {\n      execute_action( &_addressbook, &addressbook::erase );\n    }\n    else if(code==N(eosio.token) && action==N(transfer)) {\n      execute_action( &_addressbook, &addressbook::transfer );\n    }\n  }\n};",
      "language": "cplusplus"
    }
  ]
}
[/block]
The above pattern is the same as the "Exploded ABI Macro" pattern, but utilizes more verbose conditions for action handling. This results in more precise handling of actions, which is particularly useful when handling actions from external contracts.

1. Instantiate `addressbook` 
2. Have an individual `if` statement for each `code` and `action` pair. 
3. Pass a reference of the `addressbook` instance, and a caller reference to the public action of the `addressbook` class to the `execute_action` function. 

## Fleming's Dispatcher (Flexible) 
This dispatcher places most of the security logic and control inside the action handler, however, cannot use eosio-cpp's ABI generator. This dispatcher requires almost a complete rewrite of the `addressbook` contract that we've already completed. We won't rewrite the entire contract, but will rewrite one of the actions to demonstrate how this pattern could be used. 
[block:code]
{
  "codes": [
    {
      "code": "extern \"C\" void apply(uint64_t receiver, uint64_t code, uint64_t action) { \n  switch(action) {\n      case N(upsert): return upsert(receiver, code);\n      case N(notify): return notify(receiver, code);\n      case N(erase): return erase(receiver, code);\n  }\n}",
      "language": "cplusplus",
      "name": "Dispatcher"
    }
  ]
}
[/block]
To handle these requests, we move security logic that was otherwise in the dispatcher, into the action. This can provide more control, but may introduce redundancy, particularly for larger contracts. In the end, it accomplishes all the same points as the above patterns while allowing more information into the scope (namely `code`). Having access to `code` inside your action may be useful in some situations. This pattern provides the most flexibility in both the dispatcher and the action, hence "Fully Flexible."
[block:code]
{
  "codes": [
    {
      "code": "void notify(uint64_t self, uint64_t code) {\n  eosio_assert(code == self, \"These are not the droids you are looking for\");\n  auto data = unpack_action_data<notify>();\n  require_auth(get_self());\n  require_recipient(data.user);\n}",
      "language": "cplusplus",
      "name": "Notify Action"
    }
  ]
}
[/block]
1. Checks that `code == self` for security.
2. Unpacks action request into a variable where arguments can be accessed, for example `data.user`
3. This contract or `self` can be called whatever we want. When using `execute_action` or the Macros that utilize `execute_action`, "self" is automatically set to `_self`. 
[block:callout]
{
  "type": "info",
  "body": "This pattern is not compatible with eosio-cpp's ABI generator, contracts written with this pattern will need their ABI files written by hand."
}
[/block]
Please note, you will need the following declared somewhere in your contract for `unpack_action_data` to be accessible in your contract.
[block:code]
{
  "codes": [
    {
      "code": "using eosio::unpack_action_data;",
      "language": "cplusplus"
    }
  ]
}
[/block]
## Custom EOSIO_ABI macro
The above dispatchers would likely not be suitable for complex contracts with many actions. Using a custom dispatcher could introduce redundant code that's difficult to maintain, and as a unintended consequence, may introduce vulnerabilities. 

The final option is to write a custom macro that takes your unique needs into consideration. You should really only ever have to do this if your contract needs to handle actions from an external contract and your contract has more actions than is practical for the above patterns.

Below is a common custom macro you may have seen before.
[block:code]
{
  "codes": [
    {
      "code": "#define EOSIO_ABI_CUSTOM(TYPE, MEMBERS) \\\nextern \"C\" { \\\n  void apply(uint64_t receiver, uint64_t code, uint64_t action) { \\\n    auto self = receiver; \\\n    if ( (code == self && action != N(transfer)) || (code == N(eosio.token) && action == N(transfer))) { \\\n      TYPE thiscontract(self); \\\n      switch (action) { EOSIO_API(TYPE, MEMBERS) } \\\n    } \\\n  } \\\n}",
      "language": "cplusplus"
    }
  ]
}
[/block]
1. Checks if `code==self`**and** that the action **is not** transfer. If this condition is omitted, **you may introduce a vulnerability into your contract**. It allows the action through if the `code` is `eosio.token` **and** the action is `transfer`. This check prevents another contract with a transfer function from exploiting your contract.
2. Instantiates the TYPE (this would be your standard C++11 class) 
3. Add a switch for action
4. Use the EOSIO_API macro, which inserts a `case` for each `MEMBER` into your switch. Inside this case, it calls `execute_action` using a pattern very similar to the one demonstrated in the [Flexible Minimalist Dispatcher](https://developers.eos.io/eosio-home/v1.3.0/docs/writing-a-custom-dispatcher#section-flexible-minimalist-dispatcher)

You can then use this macro the same way you would with the provided `EOSIO_ABI` macro. The below includes  a fictional `transfer` action to make this demonstration relevant. 
[block:code]
{
  "codes": [
    {
      "code": "EOSIO_ABI_CUSTOM( addressbook, (upsert)(notify)(erase)(transfer) )",
      "language": "cplusplus"
    }
  ]
}
[/block]

[block:callout]
{
  "type": "info",
  "body": "The addressbook contract previously authored did not include a transfer action, it was included above to demonstrate a hypothetical case."
}
[/block]

[block:api-header]
{
  "title": "Step 3: Security, Security, Security..."
}
[/block]
Your contract's first line of security begins at your dispatcher. Understanding how the dispatching of actions to your contracts is handled is imperative to limiting exposure to logic inside your actions. Always take great caution when writing a custom dispatcher, and be aware of the security implications of each individual implementation method.
[block:api-header]
{
  "title": "Conclusion"
}
[/block]
All the examples provided achieve the appproximately same result, but with different tradeoffs regarding maintenance and explicit security. Which implementation method employed is a contract depends on the use case and some personal preferences. 

**For simple contracts that only execute internal public actions, the `EOSIO_ABI` is more than suitable, eliminates cruft and greatly decrease the chance of introducing logical errors.**